还是以之前的打印操作开始

假设我们想输出以下两句话

```
我的名字是Larmax。
我今年114514岁了。
```

正常来讲我们像下面这么写就可以了

``` c
#include <stdio.h>

int main(){
printf("My name is LARMAX.\n");
printf("I'm 114514 years old.\n");
}
```

可以看到以下输出结果

```
My name is LARMAX.
I'm 114514 years old.
```

这里只有两句话，但假设我有一百句话，里面有很多重复的名字和岁数，难道我要一个个改吗，这个时候变量就派上用场了。

简单理解变量就是把我想以后可能会更改的数据装起来，等以后真的要改了，我可以很方便的去直接改这个变量来实现一键更改，方便管理。

像上面这个例子，我要更改的是姓名和岁数。那么我可以给这两个参数来两个变量。

但是变量我们得确定是什么数据类型才能插，不过C的数据类型对于初学者来讲容易混乱。

就拿这个例子来讲，其实就是一个字符串和一个数字，数字是整数。

这两个其实都是根据他们的英文单词character（字符）和integer（整数）来命名的。分别是char和int，设立方式如下
``` c
变量类型 变量名[]=数据
```

``` c
char name[]="JACK";
int age = 24;
```

对于字符串，其实是应该规定内存大小，所以你能看到[]这个东西，因为这玩意是个数组，只不过我们没有接受用户输入，所以编译器在编译初始化的时候会动态分配，但如果需要接受用户输入等操作的时候，就需要规定大小了。当然其实也可以动态分配。（数据结构后面再说）

*tips：对于jack，看着是4个字，其实是占据5个字符，真实的情况是j,a,c,k,\0,。（\0指的是空字符，用来表示和告诉其他指令，字符串结束）*

所以真的要设置数组大小其实应该这么写

``` c
char name[5]="JACK";
int age = 24;
```
然后我们怎么引用呢，其实就是见缝插针，该放在哪里就放在哪里，最后写上变量名字。比如我一开始的那个例子。
``` c
printf("My name is Larmax");
```
那么我要要改成变量引用的模式就是
``` c
printf("My name is %s.\n",name);
```
这个时候就得问了，这个%s是什么。其实是有点类似于\n转义符号的，是说明符。

毕竟你也不想引用的时候打上character这么长一溜吧。s代表的是string（串）。那么数字呢，这里我们是十进制整数，所以要拿%d表示（decimal 十进制）其他的最后会补充。
那么就好说了，岁数的引用如下。
``` c
原指令
printf("I'm 114514 years old.\n");
引用后
printf("I'm %d years old.\n",age);
```
最后的完整指令
``` c
#include <stdio.h>

int main()
{
  char name[] = "Jack";
  int age = 24;
  printf("My name is %s.\n", name);
  printf("I'm %d years old.\n", age);
}
```
最终输出
``` output
My name is Jack.
I'm 24 years old.
```

最后放一下说明符的表。

| 格式符/修饰符   | 对应数据类型                       | 字母含义                    | 英文全称                         |     |
| --------- | ---------------------------- | ----------------------- | ---------------------------- | --- |
| `%d`      | `int`                        | **d**ecimal（十进制）        | integer                      |     |
| `%u`      | `unsigned int`               | **u**nsigned（无符号）       | unsigned integer             |     |
| `%x`/`%X` | `int`                        | **h**exadecimal（十六进制）   | hexadecimal number           |     |
| `%o`      | `int`                        | **o**ctal（八进制）          | octal number                 |     |
| `%f`      | `float` / `double`           | **f**loating point（浮点数） | floating-point number        |     |
| `%e`/`%E` | `float` / `double`           | **e**xponent（指数）        | scientific notation          |     |
| `%g`/`%G` | `float` / `double`           | **g**eneral（通用）         | general format               |     |
| `%c`      | `char`                       | **c**haracter（字符）       | character                    |     |
| `%s`      | `char*`                      | **s**tring（字符串）         | string                       |     |
| `%p`      | `void*`                      | **p**ointer（指针）         | pointer address              |     |
| `%l`      | 修饰长类型（如`long`、`long double`） | **l**ong（长）             | long                         |     |
| `%ll`     | 修饰长长类型（如`long long`）         | **l**ong **l**ong       | long long                    |     |
| `%h`      | 修饰短类型（如`short`）              | **h**alf（短）             | short                        |     |
| `%L`      | `long double`                | **L**ong double         | long double                  |     |
| `%a`/`%A` | `float` / `double`           | 十六进制浮点数                 | hexadecimal floating point   |     |
| `%n`      | `int*`                       | number of characters    | number of characters printed |     |
| `%%`      | 无                            | percent sign（百分号）       | percent sign                 |     |

其实日常能用上的也没几个，还是那句话，扫一眼就行。

补充一下，之前提到的代码是从上到下按照顺序依次执行的，所以我们可以在中间更改变量的值，比如。

``` c
#include <stdio.h>

int main()
{
  char name[] = "Jack";
  int age = 24;
  age =114514;
  printf("My name is %s.\n", name);
  printf("I'm %d years old.\n", age);
}
```

最后的输出就是

``` output
My name is Jack.
I'm 114514 years old.
```
那那个名字可以这么写吗，很可惜，不行!!!!!!!这是因为二者数据结构和内存表示不同，也不能强制重新设置相同名字并赋值，例如：
```c
#include <stdio.h>

int main()
{
  char name[] = "Jack";
  int age = 24;
  char name[] = "Mike"; /*错误做法*/
  printf("My name is %s.\n", name);
  printf("I'm %d years old.\n", age);
}
```

重复定义是不允许的。这些都和数据结构紧紧相关，后面会补充。（其实是另外一个板块的内容）

但其实再细一点是同一作用域内不能重复定义之类的，这个现在还不用理解，等到学到循环之后再探讨即可。

## 补充
其实说明符还有另外的引用，不只是说变量的引用，比如。
``` c
#include <stdio.h>
int main(){
printf("My favorite %s is %d.","number",114514);
}
```

``` output
My favorite number is 114514.
```
或者浮点数
``` c
#include <stdio.h>
int main(){
printf("My favorite %s is %f.","number",114514.0);//或者114514.0f说明是单精度
}
```

```output
My favorite number is 114514.000000.
```
这里如果不是114514.0而是114514的话，会输出0.000000这样的错误结果，原教程就犯了这个错误。毕竟数据类型不匹配。
解决方案有两个，一个是像我这样，手动改了。
第二是把这个值赋予给一个变量，再做变量转换
```c
#include <stdio.h>
int main(){
int number=114514;
printf("My favorite number is %f.",(float)number);
}
```

``` output
My favorite number is 114514.000000.
```

像(float)number这样的叫做强制类型转换。

```c
(目标类型)表达式
```
这里也就是把整数强制转换为了浮点数。需要按照情况来使用，比如整数转浮点没啥事，但浮点转整数你就得考虑一下是否会丢失一部分精度。
以及大范围数转小范围数（比如int转char），可能会造成数值溢出或者数值截断，这个就跟数据结构有关了，后面再谈。

| 类型              | 位数   | 范围（示例）                         | 典型用途            |     |
| :-------------- | :--- | :----------------------------- | :-------------- | --- |
| `char`          | 8 位  | -128 到 127（有符号）                | 存储单个字符或小整数      |     |
| `unsigned char` | 8 位  | 0 到 255（无符号）                   | 位操作或256级灰度图像    |     |
| `int`           | 32 位 | -2,147,483,648 到 2,147,483,647 | 常规整数计算          |     |
| `unsigned int`  | 32 位 | 0 到 4,294,967,295              | 位操作或无符号计数       |     |
| `long long`     | 64 位 | 很大（约 ±9×10¹⁸）                  | 需要极大范围的整数（如时间戳） |     |

后记：其实上面说了这么多，但并没有提及float和double的区别。

首先要明确的一点是精度≠小数点后位数，精度指的是有效数字位数，也就是整数部分加小数部分。

比如123.456就是6位

再回到float和double的问题，float的精度是6-7位，double精度是15-17位。

那么比如123456.7float就可以准确存储，1234567.8就不行了。

再回到printf的问题，对于printf，它是可变参数函数，而c语言规定，**传递给可变参数函数的 `float` 类型参数，会被自动提升为 `double` 类型**（这是强制规则）。

原因有两个：
- **历史原因**：早期计算机处理`float`比`double`慢，默认提升为`double`可以提高性能。
- **兼容性**：确保所有平台上参数传递行为一致。

然后我们看一下转换过程
c语言的float占据4个字节（32位），第一位存储这个数字的正负，用0表示正数，1表示负数。
然后剩下的得用例子来讲解。
比如123.4这个值，首先确定是正数那么第一位就是0.
然后将123.4拆分.变成123+0.4
将其都转化为二进制。
对于整数要不断地除以2直到商为0然后把余数倒过来
123/2=61 余1 
61/2=30 余1
30/2=15 余0
15/2=7 余1
7/2 =3 余1
3/2=1 余1
1/2=0 余1
转化为二进制的结果就是 1111011

对于小数，要不断地乘以2，然后取整数部分，这个就不用倒转了。
0.4 x 2=0.8 ->0
0.8 x 2=1.6 ->1
0.6 x2 =1.2 ->1
0.2 x2 =0.4 ->0

可以看到这个肯定是循环小数了，但是数字有效部分只能承载23位，后面的就干脆舍弃了。
然后我们把整数和小数的部分加起来，得到转换后的二进制是 1111011.0110011001100110
但是我们要用科学计数法再转换一下，也就是
$$ 1.1110110110011001100110 * 2^6 $$
然后指数我们肯定没法存在里面，所以分配了8位给了指数
也就是1个符号位+8个指数位+23个有效数字位数构成了这32位。
指数我们同样要转化为二进制，这里要注意的是不是直接把6换成二进制，而是需要加上一个偏移值（127）.主要是根据IEEE 754标准，单精度能表达的无符号整数范围是0-255（255的二进制表达就是11111111，刚好8位），所以取127位中间值。
那么6次幂转换后则为127+6=133，133转化为二进制就是
133/2=66 余1
66/2 =33 余0
33/2 =16 余1
16/2 =8 余0
8/2 =4 余0
4/2=2 余0
2/2 =1 余0
1/2 =2 余1
也就是10000101
这下这32位就是
0 10000101 11110110110011001100110
如果再把这个转化为10进制的话就是 125.699997，跟123.4差太多了。所以也印证了c语言规定，**传递给可变参数函数的 `float` 类型参数，会被自动提升为 `double` 类型**（这是强制规则）

对于double（双精度浮点数），占据8个字节，也就是64位，其中符号位为1位，指数位为11位（2-12），尾数位为52位，这样就精确多了。计算过程就不算了，太费命。