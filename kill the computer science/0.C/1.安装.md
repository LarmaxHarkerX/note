其实教程是让用CODE::BLOCK来写，毕竟这玩意能一键安装好IDE和编译器，不过我爱用VS CODE。

IDE是vscode，编译的话打着一次性吃到饱的原则，直接使用Mingw

[mingw-builds-binaries](https://github.com/niXman/mingw-builds-binaries)

解压后把bin添加至环境变量，之后在powershell输入以下命令，假如出现版本号则成功
```
g++ --version
```

然后我们还要把bin下的gcc加入到vscode，启用vscode c/c++插件，在插件设置里面有个Compiler path,点击就会跳转到配置文件，把gcc.exe路径加到里面即可
```
  "C_Cpp.default.compilerPath": "F:/PROGRAM/mingw32/bin/gcc.exe",
```
这样就算是配置成功了

接下来我们写一段测试程序
``` c 
#include <stdio.h>

#include <stdlib.h>

  

int main(){

  printf("Hello world!\n");

  return 0;

}
```

然后按Ctrl + Shift +B直接进行编译

按住Ctrl + ~打开命令提示符，不过现在默认是Powershell,可以点击加号新建一个，我觉得CMD比较好用（虽然我YTDLP脚本是拿Powershell写的）。

然后输入编译好的exe，就可以看到结果
``` output
Hello world!

```
看不到结果就把Vs关了再打开就可以了。

然后说实话这样有点麻烦，毕竟Code::Block是可以编译并运行的，这样我们就得自建一个任务

按住Ctrl + Shift + P打开命令面板，搜索**Tasks: Configure Tasks"**，然后选择 **"Create tasks.json file from template"**，再选择 **"Others"**。
将以下内容输入保存即可
``` json
{

  "version": "2.0.0",

  "tasks": [

    {

      "label": "编译并运行C程序",

      "type": "shell",

      "command": "gcc ${file} -o ${fileDirname}/${fileBasenameNoExtension}.exe && ${fileDirname}/${fileBasenameNoExtension}.exe",

      "group": {

        "kind": "build",

        "isDefault": true

      },

      "presentation": {

        "echo": true,

        "reveal": "always",

        "focus": true,

        "panel": "shared",

        "showReuseMessage": true,

        "clear": true

      },

      "problemMatcher": {

        "owner": "cpp",

        "fileLocation": ["relative", "${workspaceFolder}"],

        "pattern": {

          "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",

          "file": 1,

          "line": 2,

          "column": 3,

          "severity": 4,

          "message": 5

        }

      }

    }

  ]

}
```
但是这样会报错，因为默认是使用Powershell,

如果想着使用PowerShell来运行的话需要改为如下配置
``` json
{

  "version": "2.0.0",

  "tasks": [

    {

      "label": "编译并运行C程序",

      "type": "shell",

      "command": "gcc ${file} -o ${fileDirname}/${fileBasenameNoExtension}.exe; if ($?) { ${fileDirname}/${fileBasenameNoExtension}.exe }",

      "group": {

        "kind": "build",

        "isDefault": true

      },

      "presentation": {

        "echo": true,

        "reveal": "always",

        "focus": true,

        "panel": "shared",

        "showReuseMessage": true,

        "clear": true

      },

      "problemMatcher": {

        "owner": "cpp",

        "fileLocation": ["relative", "${workspaceFolder}"],

        "pattern": {

          "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",

          "file": 1,

          "line": 2,

          "column": 3,

          "severity": 4,

          "message": 5

        }

      }

    }

  ]

}
``` 
但如果想强制使用CMD，就用下面这个
```json
{

  "version": "2.0.0",

  "tasks": [

    {

      "label": "编译并运行C程序",

      "type": "shell",

      "command": "gcc ${file} -o ${fileDirname}/${fileBasenameNoExtension}.exe && ${fileDirname}/${fileBasenameNoExtension}.exe",

      "options": {

        "shell": {

          "executable": "cmd.exe",

          "args": ["/C"]

        }

      },

      "group": {

        "kind": "build",

        "isDefault": true

      },

      "presentation": {

        "echo": true,

        "reveal": "always",

        "focus": true,

        "panel": "shared",

        "showReuseMessage": true,

        "clear": true

      },

      "problemMatcher": {

        "owner": "cpp",

        "fileLocation": ["relative", "${workspaceFolder}"],

        "pattern": {

          "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",

          "file": 1,

          "line": 2,

          "column": 3,

          "severity": 4,

          "message": 5

        }

      }

    }

  ]

}
```
这样我们直接在相应文件按住Ctrl + Shift + p 就可以直接编译了。